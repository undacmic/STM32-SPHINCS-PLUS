#include <gtest/gtest.h>
#include "common/crypto.h"
#include "common/utils.h"
#include "common/address.h"

TEST(CryptoModuleTest, MaskGenerationFunction) {
    uint8_t PK_seed[SPX_N] = {
        0x01, 0x02, 0x03, 0x04,
        0x01, 0x02, 0x03, 0x04,
        0x01, 0x02, 0x03, 0x04,
        0x01, 0x02, 0x03, 0x04
    };    
    uint8_t ADRS[ADRS_SIZE] = { 
        0x10, 0x10, 0x10, 0x10,
        0x10, 0x10, 0x10, 0x10,
        0x10, 0x10, 0x10, 0x10,
        0x10, 0x10, 0x10, 0x10,
        0x10, 0x10, 0x10, 0x10,
        0x10, 0x10
    };
    uint8_t mask[16] = { 0 };

    uint8_t expected[32] = {
        0x11, 0x20, 0x15, 0x98,
        0x82, 0x00, 0x66, 0x8B,
        0xFF, 0x8B, 0xDE, 0x6E,
        0xE7, 0x3A, 0x3F, 0x4A,
        0x06, 0xA3, 0xD8, 0xF2,
        0xEF, 0x97, 0xCE, 0x63,
        0xFE, 0x5B, 0x7B, 0x89,
        0xEF, 0x34, 0xA0, 0x2B
    };

    uint8_t M[SPX_N + ADRS_SIZE];
    memcpy(M, PK_seed, SPX_N);
    memcpy(M + SPX_N, ADRS, ADRS_SIZE);

    mgf1(mask, M, SPX_N + ADRS_SIZE, 16);
    for (int i = 0; i < 16; i++) {
        EXPECT_EQ(expected[i], mask[i]);
    }
}

TEST(CryptoModuleTest, TweakableHashFunction) {
    uint8_t PK_seed[SPX_N] = {
        0x01, 0x02, 0x03, 0x04,
        0x01, 0x02, 0x03, 0x04,
        0x01, 0x02, 0x03, 0x04,
        0x01, 0x02, 0x03, 0x04
    };    
    uint8_t ADRS[ADRS_SIZE] = { 
        0x10, 0x10, 0x10, 0x10,
        0x10, 0x10, 0x10, 0x10,
        0x10, 0x10, 0x10, 0x10,
        0x10, 0x10, 0x10, 0x10,
        0x10, 0x10, 0x10, 0x10,
        0x10, 0x10
    };

    uint8_t M[SPX_N] = {
        0x01, 0x02, 0x03, 0x04,
        0x01, 0x02, 0x03, 0x04,
        0x01, 0x02, 0x03, 0x04,
        0x01, 0x02, 0x03, 0x04
    };

    uint8_t expected[SPX_N] = {
        0x79, 0x90, 0x48, 0x8C,
        0xF7, 0xDB, 0xB8, 0x1F,
        0x46, 0x99, 0x12, 0x19,
        0x7C, 0x78, 0xFA, 0xAF
    };

    uint8_t out[SPX_N] = { 0 };
    uint8_t PK_seed_padded[BLOCK_SIZE] = { 0 };

    BlockPad(PK_seed_padded, PK_seed);
    T_l(out, PK_seed_padded, ADRS, M, 1);

    for (int i = 0; i < SPX_N; i++) {
        EXPECT_EQ(expected[i], out[i]);
    }

}

TEST(CryptoModuleTest, ChainingFunctionTest) {
    uint8_t out[SPX_N];

    uint8_t PK_seed[SPX_N] = {
        0x01, 0x02, 0x03, 0x04,
        0x01, 0x02, 0x03, 0x04,
        0x01, 0x02, 0x03, 0x04,
        0x01, 0x02, 0x03, 0x04
    };  

    uint8_t X[SPX_N];
    memset(X, 0, SPX_N);

    uint8_t ADRS[ADRS_SIZE];
    memset(ADRS, 0, ADRS_SIZE);
    chain(out, X, 0, SPX_W - 1, PK_seed, ADRS);

    uint8_t expected[SPX_N] = {
        0xCF, 0x04, 0x62, 0x1D,
        0x2F, 0x08, 0xFD, 0xFB,
        0xDD, 0x55, 0xF5, 0x09,
        0x33, 0xC5, 0x05, 0x56
    };

    for (int i = 0; i < SPX_N; i++) {
        EXPECT_EQ(expected[i], out[i]);
    }
}


TEST(CryptoModuleTest, WotsPublicKeyGenerationFunctionTest) {
    uint8_t out[SPX_N];
    uint8_t expected[SPX_N] = {
        0xD3, 0xD5, 0xB2, 0x67,
        0x5A, 0xC6, 0xA5, 0xD1,
        0x2F, 0x11, 0x6F, 0xAC,
        0x97, 0xD5, 0x27, 0x27
    };

    uint8_t SK_seed[SPX_N];
    memset(SK_seed, 0, SPX_N);

    uint8_t PK_seed[SPX_N] = {
        0x01, 0x02, 0x03, 0x04,
        0x01, 0x02, 0x03, 0x04,
        0x01, 0x02, 0x03, 0x04,
        0x01, 0x02, 0x03, 0x04
    }; 

    uint8_t ADRS[ADRS_SIZE];
    memset(ADRS, 0, ADRS_SIZE);

    wots_PKgen(out, SK_seed, PK_seed, ADRS);

    for (int i = 0; i < SPX_N; i++) {
        EXPECT_EQ(expected[i], out[i]);
    }
}

TEST(CryptoModuleTest, WotsSignatureGenerationVerificationTest) {
    uint8_t ADRS[ADRS_SIZE];
    memset(ADRS, 0, ADRS_SIZE);

    uint8_t SK_seed[SPX_N];
    memset(SK_seed, 0, SPX_N);
    
    uint8_t PK_seed[SPX_N] = {
        0x01, 0x02, 0x03, 0x04,
        0x01, 0x02, 0x03, 0x04,
        0x01, 0x02, 0x03, 0x04,
        0x01, 0x02, 0x03, 0x04
    };

    uint8_t M[WOTS_LEN];
    memset(M, 0, WOTS_LEN);

    uint8_t wotsPK[SPX_N];
    wots_PKgen(wotsPK, SK_seed, PK_seed, ADRS);

    uint8_t sig[SPX_N * WOTS_LEN];
    memset(ADRS, 0, ADRS_SIZE);
    wots_sign(sig, M, SK_seed, PK_seed, ADRS);

    uint8_t wotsExtractedPK[SPX_N];
    memset(ADRS, 0 ,ADRS_SIZE);
    wots_pkFromSig(wotsExtractedPK, sig, M, PK_seed, ADRS);

    for (int i = 0; i < SPX_N; i++) {
        EXPECT_EQ(wotsPK[i], wotsExtractedPK[i]);
    }
}

